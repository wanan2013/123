https://www.cnblogs.com/huanongying/p/7021555.html

事务特点：
1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。

　　 2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。

　　 3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

　　 4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

并发访问问题
1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

　　2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。

　　3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

　　总结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表

5.4     inndob四种事务的隔离级别都是什么
四种隔离级别：
readuncommitted  未提交读
readcommitted          读取已提交
repeatableread          可重读
serializable  串行化读
不同级别的现象：
脏读：一个事务可以读取到另一个事务尚未提交的数据
不可重复读：两个事务读取同一条记录，两次读取的结果不一样
幻读：在一个事务中，由于其他插入操作事务的提交，导致返回了以前不存在的记录
不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差。

事务隔离级别	               脏读 不可重复读	幻读
读未提交（read-uncommitted）	是	是	是
不可重复读（read-committed）	否	是	是
可重复读（repeatable-read）	否	否	是
串行化（serializable）	        否	否	否
 
四、查看日志隔离级别
MySQL > select  @@TX_ISOLATION;
 
+++++++++++++++++++++++++++++++++++++
https://blog.csdn.net/mysql_lover/article/details/54925955
mysql 事物如何通过日志来实现
5.1redo undo

Redo用于前滚 undo用于回滚和一致性读

redo：在页修改的时候，先写到redo log buffer 里面，然后写到redo log 的文件系统缓存里面(fwrite)，然后再同步到磁盘文件（fsync）。 每当有操作执行前，将数据真正更改时，先前相关操作写入重做日志。这样当断电，或者一些意外，导致后续任务无法完成时，系统恢复后，可以继续完成这些更改

Undo：在MySQL5.5之前，undo只能存放在ibdata*文件里面，5.6之后，可以通过设置innodb_undo_tablespaces参数把undo log存放在ibdata*之外。当一些更改在执行一半时，发生意外，而无法完成，则可以根据撤消日志恢复到更改之前的壮态。

5.2事务时如何通过日志来实现的

因为事务在修改页时，要先记undo，在记undo之前要记undo的redo，然后修改数据页，再记数据页修改的redo。Redo（里面包括undo的修改）一定要比数据页先持久化到磁盘。当事务需要回滚时，因为有undo，可以把数据页回滚到前镜像的状态，崩溃恢复时，如果redo log中事务没有对应的commit记录，那么需要用undo把该事务的修改回滚到事务开始之前。如果有commit记录，就用redo前滚到该事务完成时并提交掉。

+++++++++++++++++++++++

5.3     mysql binlog的几种日志录入格式以及区别

（1） 各种日志格式的涵义

Statement/row模式，mixed模式是二者的结合

（2） 适用场景
在一条SQL操作了多行数据时，statement更节省空间，row更占用空间。但是row模式更可靠。

（3）结合第一个问题，每一种日志格式在复制中的优劣。

Statement可能占用空间会相对小一些，传送到slave的时间可能也短，但是没有row模式的可靠。Row模式在操作多行数据时更占用空间，但是可靠。
 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
pt-table-checksum校验mysql主从数据一致性
pt-table-checksum是著名的percona-toolkit工具集的工具之一。它通过在主库执行基于statement的sql语句来生成主库数据块的checksum，把相同的sql语句传递到从库，并在从库上计算相同数据块的checksum，最后，比较主从库上相同数据块的checksum值，由此判断主从数据是否一致。这种校验是分表进行的，在每个表内部又是分块进行的，而且pt工具本身提供了非常多的限流选项，因此对线上服务的冲击较小。
https://www.cnblogs.com/huminxxl/p/3978559.html

+++++++++++++++++++++++++++++++++++++++++++++++++
从完全备份文件里恢复 单个库

从全备份中只恢复report库 [root@mha2 backup]#  mysql -uroot -p123456 db1 --one-database < allbak.sql



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
innodb存储引擎结构 https://www.jianshu.com/p/fdc5e066433a
二、Innodb引擎锁知识点

1、锁的粒度

锁有行锁（锁加在行上）和表锁（锁加在表上），Innodb的锁默认是行锁（也支持表锁），需要注意的是，

行锁（与oracle不同，oracle的锁是加在数据块上的数据行上）是加在索引上的，也就是说，只有通过索引检索数据，才会使用行锁，否则，将使用表锁。

2、锁的事务隔离级别

锁的事务有四个隔离级别，未提交读（read uncommited、脏读）、已提交读（read commited、不可重复读）、

可重复读（repeatable read、幻读）、可串行化（serializable）,其中mysql默认事务隔离级别是可重复读，

对于该级别出来的幻读，mysql是通过多版本并发控制（mvcc，multiversion concurrency control）处理的。

3、innodb锁的类型

行级锁分为共享锁（S锁）、排他锁（X锁）。

为了行锁和表锁共存，实现更细粒度控制的表锁分为意向共享锁（IS锁，表锁）、意向排它锁（IX锁，表锁），

注意意向锁是Innodb自动加的，对于update、delete、insert，Innodb会自动加排他锁，对于select不会加锁。

共享锁（S锁）：允许获得锁的事务读某行，阻止其它事务获取相同行的排它锁。

排他锁（X锁）：允许获取锁的事务更新数据，阻止其它事务获取相同行的共享锁和排它锁。

意向共享锁（IS锁）：事务在打算给数据加共享锁前，必须获得该表的意向共享锁。

意向排它锁（IX锁）：事务在打算给数据加排它锁前，必须获得该表的意向排它锁。

4、间隙锁（next-key）锁

正常加锁时，除检索范围内的已存在数据行的索引会被加锁，在检索范围内，但不存的数据行，

这部分叫做间隙，innodb也会对这个间隙加锁，即是间隙锁。也就是说在检索范围内，不管真实是否有数据行，都会被锁住。


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MySQL：binlog日志文件（mysql-bin.000001）和事务日志文件（ib_logfile0）都是二进制日志文件，有什么区别；事务日志文件怎么查看其内容。

https://blog.csdn.net/donghaixiaolongwang/article/details/60961603
Innodb的事务日志是指Redo log，简称Log,保存在日志文件ib_logfile*里面（去mysql数据目录下看下）。Innodb还有另外一个日志Undo log，但Undo log是存放在共享表空间里面的（ibdata*文件，存储的是check point日志序列号）。

由于Log和Checkpoint紧密相关，因此将这两部分合在一起分析。

名词解释：LSN，日志序列号，Innodb的日志序列号是一个64位的整型。

